/// PKCE (Proof Key for Code Exchange) code verifier as specified in
/// [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636).
///
/// The code verifier is a cryptographically random string used to secure the authorization code
/// flow against interception attacks. It's generated by the client and used to derive a code
/// challenge that's sent during authorization.
///
/// # Params
/// - `LENGTH` - Must be between 43 and 128. Validated at compile time through
///   [`generate`](CodeVerifier::generate).
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub struct CodeVerifier<const LENGTH: usize = 128> {
    code_verifier: String,
}

impl<const LENGTH: usize> CodeVerifier<LENGTH> {
    /// Generate a new `CodeVerifier`.
    ///
    /// see: <https://datatracker.ietf.org/doc/html/rfc7636>
    #[track_caller]
    pub(crate) fn generate() -> Self {
        use base64::{Engine, engine::general_purpose::URL_SAFE_NO_PAD};
        use rand::RngExt;

        const CHARSET: &[u8] =
            b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";

        const {
            assert!(
                !(LENGTH < 43 || LENGTH > 128),
                "Invalid code verifier length"
            );
        }

        let mut rng = rand::rng();

        // Leveraging the base64 encoding ratio of encoding 3 bytes into 4 characters
        // with the fact that we use the NO_PAD config.
        let bytes_needed = (LENGTH * 3) / 4;

        let mut result = String::with_capacity(bytes_needed);
        for next_char in
            (0..bytes_needed).map(|_i| CHARSET[rng.random_range(0..CHARSET.len())] as char)
        {
            result.push(next_char);
        }

        let code_verifier = URL_SAFE_NO_PAD.encode(&result);

        assert_eq!(code_verifier.len(), LENGTH);

        Self { code_verifier }
    }

    /// Create a `CodeChallenge` from the verifier. Keep this verifier around for later validation.
    pub(crate) fn to_code_challenge(&self) -> CodeChallenge {
        use base64::{Engine, engine::general_purpose::URL_SAFE_NO_PAD};
        use sha2::Digest;

        let mut hasher = sha2::Sha256::new();
        hasher.update(self.code_verifier.as_bytes());
        let digest = hasher.finalize();

        let code_challenge = URL_SAFE_NO_PAD.encode(digest);

        CodeChallenge {
            code_challenge,
            code_challenge_method: CodeChallengeMethod::S256,
        }
    }

    /// Get the code verifier string.
    ///
    /// # Returns
    /// The code verifier as a string slice.
    pub fn code_verifier(&self) -> &str {
        self.code_verifier.as_str()
    }
}

/// The method used to derive the code challenge from the code verifier.
///
/// PKCE supports multiple challenge methods, but this library only implements `S256`
/// (the SHA-256 hash), which is the recommended and most secure method not requiring special
/// extensions.
///
/// See [RFC 7636 Section 4.3](https://datatracker.ietf.org/doc/html/rfc7636#section-4.3).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CodeChallengeMethod {
    /// SHA-256 hash method. The code challenge is `BASE64URL(SHA256(code_verifier))`.
    ///
    /// This is the recommended method and provides strong security.
    S256,
}

impl CodeChallengeMethod {
    /// Get the string representation of the challenge method.
    ///
    /// # Returns
    /// `"S256"` for the SHA-256 method.
    pub(crate) fn as_str(self) -> &'static str {
        match self {
            CodeChallengeMethod::S256 => "S256",
        }
    }
}

/// PKCE code challenge derived from a [`CodeVerifier`](CodeVerifier).
///
/// The code challenge is sent to the authorization server during the initial authorization request.
/// Later, when exchanging the authorization code for tokens, the original code verifier is sent to
/// prove that the same client that initiated the flow is completing it.
///
/// The challenge is computed using the chosen `CodeChallengeMethod`.
///
/// # Internal Use
/// This is typically managed internally by the library. You usually don't need to
/// interact with this type directly.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CodeChallenge {
    code_challenge: String,
    code_challenge_method: CodeChallengeMethod,
}

impl CodeChallenge {
    /// Get the code challenge string.
    ///
    /// This is the BASE64URL-encoded SHA-256 hash of the code verifier.
    ///
    /// # Returns
    /// The code challenge as a string slice.
    pub fn code_challenge(&self) -> &str {
        self.code_challenge.as_str()
    }

    /// Get the challenge method used.
    ///
    /// # Returns
    /// The [`CodeChallengeMethod`] used to derive this challenge (always `S256`).
    pub fn code_challenge_method(&self) -> CodeChallengeMethod {
        self.code_challenge_method
    }
}

#[cfg(test)]
mod test {
    use assertr::prelude::*;

    use super::{CodeChallengeMethod, CodeVerifier};

    #[test]
    fn test_43() {
        let verifier = CodeVerifier::<43>::generate();
        assert_that(verifier.code_verifier()).has_length(43);

        let challenge = verifier.to_code_challenge();
        assert_that(challenge.code_challenge_method()).is_equal_to(CodeChallengeMethod::S256);
        assert_that(challenge.code_challenge()).has_length(43);
    }

    #[test]
    fn test_128() {
        let verifier = CodeVerifier::<128>::generate();
        assert_that(verifier.code_verifier()).has_length(128);

        let challenge = verifier.to_code_challenge();
        assert_that(challenge.code_challenge_method()).is_equal_to(CodeChallengeMethod::S256);
        assert_that(challenge.code_challenge()).has_length(43);
    }
}
