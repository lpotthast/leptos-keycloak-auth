/// Cryptographically secure nonce for `OpenID Connect` ID token validation.
///
/// A nonce (number used once) is a random value that binds an ID token to a specific
/// authorization request, preventing ID token replay attacks. An attacker cannot reuse an ID token
/// from a different session because the nonce claim will not match and the attacker cannot alter
/// the claim in his known-but-encrypted token.
///
/// The nonce is:
/// - Generated by us (the client) before redirecting to Keycloak's authorization endpoint.
/// - Included in the authorization request.
/// - Returned by Keycloak in the ID token's `nonce` claim.
/// - Validated by us to ensure the ID token was issued for our specific request.
#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub struct Nonce {
    nonce: String,
}

impl Nonce {
    /// Generate a new cryptographically secure nonce using 32 bytes of random data,
    /// base64 url encoded as a 43 character string.
    pub fn new() -> Self {
        use base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};
        use rand::Rng;

        let mut rng = rand::rng();
        let bytes: [u8; 32] = rng.random();
        let nonce = URL_SAFE_NO_PAD.encode(bytes);

        Self { nonce }
    }

    pub fn as_str(&self) -> &str {
        &self.nonce
    }
}

impl Default for Nonce {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use assertr::assert_that;
    use assertr::prelude::*;
    use std::collections::HashSet;

    #[test]
    fn generate_nonce_on_creation() {
        let nonce = Nonce::new();
        assert_that(nonce.as_str()).is_not_empty().has_length(43);
    }

    #[test]
    fn nonces_are_unique() {
        let mut nonces = HashSet::new();

        for _ in 0..100 {
            assert_that(nonces.insert(Nonce::new()))
                .with_detail_message("Generated duplicate nonce.")
                .with_detail_message(format!("{nonces:?}"))
                .is_true();
        }
    }
}
